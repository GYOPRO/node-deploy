# Node.js

# 1. 노드 js란?

## 1.1 핵심 개념 이해하기

### 1.1.1 서버

노드를 통해 다양한 자바크립트 애플리케이션을 실행할 수 있지만, 노드는 서버 애플케이션을 실행하는데 제일 많이 사용한다.

서버는 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 또는 프로그램.

서버는 클라이언트의 요청에 대해 응답한다. 그래서 노드는 자바스크립트 프로그램이 서버로서 기능하기 위한 도구를 제공하므로 서버 역할을 수행할 수 있다.

### 1.1.2 자바스크립트 런타임

Node.js 는 Chrome V8 Javascript 엔진으로 빌드된 Javascript 런타임 입니다.

- 공식 사이트에 게시된 노드 소개글.

### 1.1.3 이벤트 기반

이벤트가 발생할 때, 미리 지정해둔 작업을 수행하는 방식.

“이벤트 리스너(Event Listener)에 콜백(callback) 함수를 등록한다.” 는 말은,

이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두는 것을 의미한다.

- 이벤트 루프 : 이벤트 발생시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당
- 백그라운드 : setTimeout 과 같은 타이머나 이벤트 리스너들이 대기하는 곳
- 태스크 큐 : 이벤트 발생 후, 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백 함수를 보낸다. 정해진 순서대로 콜백들이 줄을 서 있어서 콜백 큐라고도 부른다.

### 1.1.4 논 블로킹 I/O

- 논블로킹이란 ?
    
    이전 작업이 완료 될 때까지 대기하지 않고 다음 작업을 수행하는 것을 의미한다.
    
    즉, 작업들이 모두 동시에 처리될 수 있는 작업이며, 같은 작업을 더 짧은 시간안에 처리할 수 있다.
    
- 블로킹이란 ?
    
    이전 작업이 끝나야만 다음작업을 수행하는 것을 의미한다.
    
- setTimeout(callback, 0) 은 코드를 논 블로킹으로 만들기 위해 사용하는 기법 중 하나.

노드에서는 동기와 블로킹, 비동기와 논블로킹이 서로 유사하다는 것만 알아두자.

### 1.1.5 싱글 스레드

스레드가 하나뿐이라는 의미. 자바스크립트 코드가 동시에 실행될 수 없는 이유이기도 함.

- 프로세스와 스레드의 차이
1. 프로세스
- 운영체제에서 할당하는 작업의 단위
- 노드나 웹 브라우저 같은 프로그램은 개별적인 프로세스
- 프로세스 간에는 메모리 등의 자원을 공유하지 않음
1. 스레드
- 프로세스 내에서 실행되는 흐름의 단위
- 프로세스는 스레드를 여러개 생성해서 여러 작업을 동시에 처리할 수 있음
- 스레드들은 부모 프로세스의 자원을 공유
- 같은 주소의 메모리에 접근 가능하므로 데이터를 공유할 수 있음

## 1.2 서버로서의 노드

노드 서버의 장단점은 싱글 스레드, 논 블로킹 모델의 장단점과 크게 다르지 않다.

노드 사용자들이 말하는 가장 큰 장점은 언어로 자바스크립트를 사용한다는 것이다. 이것이 생산성이 중요한 기업이 노드를 채택하는 이유이다. 하지만 로드 밸런싱에 특화된 웹 서버에 비해서는 속도가 느리다.

- 노드의 장점
- 멀티 스레드 방식에 비해 적은 컴퓨터 자원 사용
- I/O 작업이 많은 서버로 적합
- 멀티 스레드 방식보다 쉬움
- 웹 서버가 내장되어 있음
- 자바스크립트를 사용함
- JSON 형식과 쉽게 호환됨
- 노드의 단점
- 기본적으로 싱글 스레드라서 CPU 코어를 하나만 사용
- CPU 작업이 많은 서버로는 부적합
- 하나뿐인 스레드가 멈추지 않도록 관리가 필요함
- 서버 규모가 커졌을 때 서버를 관리하기 어려움
- 어중간한 성능

## 1.3 서버 외의 노드

노드 기반으로 돌아가는 대표적인 웹 프레임워크는 앵귤러(Angular), 리액트(React), 뷰(Vue) 등이 있다.

[node.js 소켓 통신으로 postgresql 트리거](https://bluebead38.blogspot.com/2019/04/postgresql-nodejs-insert.html)

---

# 2. 모던 자바스크립트

## 2.1 ES2015+

2015년 자바스크립트 문법에 매우 큰 변화가 있었다. 이것이 ES6이라고도 불리우는 ES2015가 등장한 것이다. 2015년을 기점으로 매년 문법 변경 사항이 발표되고 있으며, 이 책에서는 ES2015이상의 자바스크립트를 통틀어서 ES2015+라고 표현한다.

### 2.1.1 const, let

const 와 let 이 공통적으로 가지는 특징인 블록 스코프(범위)의 차이

- var 은 함수 스코프를 가지므로 if문의 블록과 관계없이 접근할 수 있음.
- 하지만 const 와 let은 블록 스코프를 가지므로 블록 밖에서는 변수에 접근할 수 없다.

const 는 한 번 값을 할당하면 다른 값을 할당할 수 없다. 또한, 초기화 할 때 값을 할당하지 않으면 에러가 난다. 그래서 const로 선언한 변수를 상수라고 부르기도 한다.

### 2.1.2 템플릿 문자열

ES2015 문법에 새로운 문자열이 생겼다. 기존 문자열과 다르게 백틱(`) (맥에서는 영문키로 바꾸고 ₩ 버튼을 누르면된다..) 으로 감싼다. 특이한 점은 문자열 안에 변수를 넣을 수 있다는 것이다.

```
const a = 10;
const b = 20;
const str = `${a} 곱하기 2는 ‘${b}'`;
```

${변수} 형식으로 변수를 더하기 기호 없이 문자열에 넣을 수 있고 큰따옴표나 작음따옴표도 함께 사용할 수 있다.

### 2.1.3 객체 리터럴

객체의 메서드에 함수를 연결할 때, 콜론(:)과 function을 붙이지 않아도 된다.

속성명과 변수명이 동일한 경우에는 한 번만 써도 된다.

### 2.1.4 화살표 함수(arrow function)

새로 추가된 기능. 기존의 function() {} 도 그래도 사용가능 하다.

```
function multiple(a, b) {
	return a*b;
}

const multiple2 = (a, b) => {
	return a*b;
};
```

function 선언 대신 => 기호로 함수를 선언한다. 변수에 대입하면, 나중에 재사용 가능하다.

- * this 바인드 방식

this 를 사용해야 하는 경우에는 화살표 함수와 함수 선언문(function)중에서 하나를 고르면 된다.

### 2.1.5 구조분해 할당

구조분해 할당을 사용하면 객체와 배열로부터 속성이나 요소를 쉽게 꺼낼 수 있다.

배열에 대한 구조분해 할당 문법

```
const arr = [‘nari’, {}, 27, true];
const [name, birthday, , bool] = arr;
```

name 은 배열의 첫 번째 요소, birthday는 두 번째 요소, bool은 네번째 요소이다. 중간에 27은 빈칸으로 두었으므로 변수명을 지어주지않아서 무시하면된다.

### 2.1.6 클래스

클래스 문법이 추가되었지만 다른 언어처럼 클래스 기반으로 동작하는 것이 아니라 프로토타입 기반으로 동작한다. 프로토타입 기반 문법을 보기 좋게 클래스로 바꾼것이라고 이해하면 된다.

### 2.1.7 프로미스

자바스크립트와 노드에서는 주로 비동기를 접한다. ES2015부터는 자바스크립트와 노드의 API들이 콜백 대신 프로미스(Promise)기반으로 재구성되며, 콜백 지옥(callback hell) 현상을 극복했다는 평가를 받고 있다.

프로미스에는 규칙이 있다. 먼저는 프로미스 객체를 생성해야한다. new Promise로 프로미스를 생성할 수 있으며, 그 내부에 resolve와 reject 를 매개변수로 갖는 콜백함수를 넣는다. 이렇게 만든 프로미스 변수에는 then 과 catch 메서드를 붙일 수 있으며, resolve가 호출되면 then이 실행되고, reject가 호출되면 catch가 실행된다. finally 부분은 성공/실패 여부와 상관없이 실행된다.

쉽게 말하자면, 실행은 바로 하되 결과값은 나중에 받는 객체이다. 결과값은 실행이 완료된 후 then 이나 catch 메서드를 통해서 받는다.

### 2.1.8 async/await

이 기능은 노드 7.6버전부터 지원되는 기능이다. 비동기 위주로 프로그래밍을 할 때 도움이 된다. 프로미스가 콜백지옥을 해결했지만, then과 catch가 계속 반복되어 코드가 장황하다. 하지만 async/await 문법은 프로미스를 사용한 코드를 한 번 더 깔끔하게 줄여준다.

## 2.2 프런트엔드 자바스크립트

### 2.2.1 AJAX

Asynchronous Javascript And XML 의 약자로 비동기적 웹 서비스를 개발할 때 사용하는 기법이다. 이름에 XML이 들어있지만 꼭 사용해야하는 것은 아니여서 요즘은 JSON을 많이 사용하고 있다.

쉽게 말해서 페이지 이동없이 서버에 요청을 보내고 응답을 받는 기술이다.

### 2.2.2 FormData

HTML form 태그의 데이터를 동적으로 제어할 수 있는 기능으로 AJAX와 함께 사용된다.

```
const formData = new FormData();

// 키-값 형식의 데이터를 저장할 수 있음. 키 하나에 여러 개의 값 추가 가능
formData.append(‘name’, ‘nari’);

// 주어진 키에 해당하는 값이 있는지 여부를 반환함
formData.has(‘name’); //true

// 주어진 키에 해당하는 값 하나를 가져옴
formData.get(‘name’);

formData.append(‘name’, [‘shin’, ‘young’]);

// 주어진 키에 해당하는 모든 값을 가져옴
formData.getAll(‘name’); // nari, shin, young

// 현재키를 제거하는 메서드
formData.delete(‘name’);
formData.get(‘name); //null. 바로위에서 name 키에 해당하는 값을 지웠으므로.

// 현재 키를 수정하는 메서드
formData.set(‘name’, ‘rebekah’);
formData.getAll(‘name’); // [‘rebekah’]
```

### 2.2.3 encodeURIComponent, decodeURIComponent

AJAX 요청을 보낼 때, `‘http://localhost4000/나리’`처럼 주소에 한글이 들어가는 경우가 있다. 서버에 따라서 한글 주소를 이해하지 못하는 경우가 있는데, 이 때 window 객체의 메서드인 encodeURIComponent 메서드를 사용한다.

`https://localhost4000/${encodeURIComponenet(‘나리’)}’`

이렇게 할 경우 한글주소가 % 와 영어, 숫자가 섞인 문자열로 변환된다.

그리고 다시 변환시킬때, 받는 쪽에서는 decodeURIComponent 를 사용하면 한글로 다시 바뀐다.

### 2.2.4 데이터 속성과 dataset

데이터 속성(Data Attribute)

HTML과 관련된 데이터를 저장하는 공식적인 방식.

노드를 웹 서버로 사용하는 경우, 서버에서 보내준 데이터를 프론트엔드 어디에 넣어야할지 고민하게 되는데, 첫 번째로는 ‘보안’ 을 고려해야한다.

---

# 3. 노드 시작하기

## 3.1 REPL 사용하기

REPL(Read Eval Print Loop) :: 입력한 코드를 읽고(Read), 해석하고(Eval), 결과물을 반환하고(Print), 종료할 때까지 반복한다(Loop) 는 의미

한두 줄짜리 코드를 테스트하는 용도로는 적합하지만 긴 코드의 경우 자바스크립트 파일로 만든 후 파일을 통째로 실행해보는 것이 좋다.

## 3.2 JS 파일 실행하기

콘솔에서 `node [자바스크립트 파일경로]` 로 실행한다. 확장자(.js) 는 생략해도 된다.

## 3.3 모듈로 만들기

모듈이란 ? 특정한 기능을 하는 함수나 변수들의 집합

보통 파일 하나가 모듈 하나가 된다. 모듈로 만들어두면 여러 프로그램에 해당 모듈을 재사용할 수 있다. 파일별로 코드를 모듈화할 수 있어서 관리하기가 편하다.

## 3.4 노드 내장 객체 알아보기

### 3.4.1 global

브라우저의 window와 같은 전역 객체. 모든 파일에서 접근 가능하다.

생략해서 사용가능한데, 대표적인 예로 노드 콘솔에 로그를 기록하는 console 객체도 원래는 global.console 이다.

- * 노드에는 DOM, BOM이 없어서 window, document객체는 사용할 수 없다.

### 3.4.2 console

보통 console 객체는 디버깅을 위해 사용하며, 노드에서는 console 이 global 객체 안에 들어있으며, 브라우저에서의 console과 거의 비슷하다. 다른 로깅함수들을 다뤄보려한다.

console.time(레이블) : console.timeEnd(레이블)과 대응되어 같은 레이블을 가진 time과 timeEnd 사이의 시간을 측정

console.log(내용) : 평범한 로그를 콘솔에 표시합니다. Console.log(내용, 내용, …) 처럼 여러 내용을 동시에 표시

console.error(에러내용) : 에러를 콘솔에 표시

console.table(배열) : 배열의 요소로 객체 리터럴을 넣으면 객체의 속성들이 테이블 형식으로 표현된다.

console.dir(객체, 옵션) : 객체를 콘솔에 표시할 때 사용

console.trace(레이블) : 에러가 어디서 발생했는지 추적할 수 있음

### 3.4.3 타이머

타이머 기능을 제공하는 함수

setTimeout(콜백 함수, 밀리초) : 주어진 밀리초(1,000분의 1초)이후에 콜백 함수를 실행

setInterval(콜백 함수, 밀리초) : 주어진 밀리초마다 콜백 함수를 반복 실행

setImmediate(콜백 함수) : 콜백 함수를 즉시 실행

아이디를 사용하여 타이머를 취소할 수 있음

clearTimeout(아이디) : setTimeout 을 취소

clearInterval(아이디) : setInterval 을 취소

clearImmediate(아이디) : setImmediate 를 취소

### 3.4.4 **filename,** dirname

노드에서는 파일 사이에 모듈 관계가 있는 경우가 많아서 때로는 현재 파일의 경로나 파일명을 알아야한다. 노드는 `__filename`, `__dirname` 이라는 키워드로 경로에 대한 정보를 제공한다.

### 3.4.5 module, exports, require

module 객체 말고 exports 객체로도 모듈을 만들 수 있다. 두개가 동일하게 동작하는 이유는 module.exports 와 exports 가 같은 객체를 참조하기 때문이다. 다시말해서 exports와 module.exports에는 참조 관계가 있으므로 한 모듈에 이 두가지를 동시에 사용하는 것는 좋지않다.

> 노드에서 this를 사용할 때는 주의할 점이 있다. 최상위 스코프에 존재하는 this는 module.exports(또는 exports 객체)를 가리킨다. 하지만, 함수 선언문 내부의 this는 global 객체를 가리킨다.
> 
- 순환 참조(circular dependency)순환 참조가 있을 경우 순환 참조되는 대상을 빈 객체로 만든다. 이 때 에러가 발생하지 않고 빈 객체로 변경되어서 예기치 못한 동작이 발생할 수 있다. 그래서 순환 참조가 발생하지 않도록 구조를 잘 잡는 것이 중요하다.

### 3.4.6 process

process 객체는 현재 실행되고 있는 노드 프로세스에 대한 정보를 담고있다.

1. process.envREPL에 입력해보면 매우 많은 정보가 출력되는데, 이 정보들은 시스템의 환경 변수이다.대표적으로 UV_THREADPOOL_SIZE 와 NODE_OPTIONS 가 있다.NODE_OPTIONS :: 노드를 실행할 때의 옵션들을 입력받는 환경 변수UV_THREADPOOL_SIZE :: 노드에서 기본적으로 사용하는 스레드풀의 스레드 개수를 조절할 수 있게 함.
2. process.nextTick(콜백)이벤트 루프가 다른 콜백 함수들보다 nextTick의 콜백 함수를 우선으로 처리하도록 만든다. 즉, setImmediate나 setTimeout보다 먼저 실행된다. 또한, resolve된 Promise도 nextTick처럼 다른 콜백들보다 우선시되는데, process.nextTick과 Promise를 마이크로태스크(microtask)라고 따로 구분지어 부른다.
3. process.exit(코드)실행 중인 노드 프로세스를 종료한다. 서버 외의 독립적인 프로그램에서 수동으로 노드를 멈추기 위해 사용한다.

## 3.5 노드 내장 모듈 사용하기

### 3.5.1 os

os모듈에는 운영체제의 정보가 담겨있어서 가져올 수 있으며 process객체와 겹치는 부분도 조금 있다.

### 3.5.2 path

폴더와 파일의 경로를 쉽게 조작하도록 도와주는 모듈.

path 모듈이 필요한 이유 중 하나는 운영체제별로 경로 구분자가 다르기 때문이다. 크게는 윈도 타입과 POSIX타입으로 구분된다. POSIX는 유닉스 기반의 운영체제들을 의미하며 맥과 리눅스가 속해 있다.

1. 윈도: C:\Users\nari> \ (백슬레시)로 구분한다.
2. POSIX: /home/nari> /(슬레시)로 구분한다.

### 3.5.3 url

인터넷 주소를 쉽게 조작하도록 도와주는 모듈.

노드 버전7에서 추가된 WHATWG(웹 표준을 정하는 단체의 이름)방식의 url과 예전부터 노드에서 사용하던 방식의 url 두 가지 방법이 있다.

- WHATWG :: url 모듈 안에 URL 생성자가 있어서 이 생성자에 주소를 넣고 객체로 만들면 주소가 부분별로 정리가 된다. username, password, origin, searchParams 속성은 WHATWG에만 존재한다.
- 기존 노드 방식에서는 메서드를 주로 사용한다.url.parse(주소) :: 주소를 분해한다. WHATWG 방식과 비교해보면 username, password 대신에 auth 속성, searchParams 대신에 query가 있다.url.format(객체) :: WHATWG 방식 url과 기존 노드의 url을 모두 사용할 수 있다. 분해되었던 url객체를 다시 원래 상태로 조립한다.

### 3.5.4 querystring

WHATWG 방식의 url 대신 기존 노드의 url을 사용할 때, search 부분을 사용하기 쉽게 객체로 만드는 모듈.

- querystring.parse(쿼리) : url의 query 부분을 자바스크립트 객체로 분해
- querystring.stringify(객체) : 분해된 query 객체를 문자열로 다시 조립

### 3.5.5 crypto

다양한 방식의 암호화를 도와주는 모듈.

1. 단방향 암호화비밀번호는 보통 단방향 암호화 알고리즘을 사용해서 암호화한다.단방향 암호화란? 복호화할 수 없는 암호화 방식. 즉, 한 번 암호화하면 원래 문자열을 찾을 수 없어서 암호화라고 표현하는 대신 해시 함수라고 부르기도 한다.
2. 양방향 암호화양방향 대칭형 암호화는 암호화된 문자열을 복호화할 수 있으며, 키가 사용된다. 그래서 복호화하려면 암호화할 때 사용한 키와 같은 키를 사용해야한다.

### 3.5.6 util

이름처럼 각종 편의 기능을 모아둔 모듈.

계속해서 API가 추가되고 있지만, 가끔 deprecated되어 사라지는 경우도 있다.

자주 사용하는 메서드 2개를 소개해보자면,

- util.deprecate: 함수가 deprecated 처리되었음을 알려준다. 즉, 함수가 조만간 사라지거나 변경될때 알려줄 수 있음.
- util.promisify : 콜백 패턴을 프로미스 패턴으로 바꿔준다.

### 3.5.7 worker_threads

노드에서 **멀티 스레드 방식으로 작업**하는 방법은 worker_threads 모듈로 가능하다.

멀티 스레딩을 할 때는 일을 나눠서 처리하도록 하는 게 제일 어렵다. 스레드를 생성하고 스레드 사이에서 통신하는 데 상당한 비용이 발생하므로, 이 점을 고려해서 멀티 스레딩을 해야한다.

### 3.5.8 child_process

노드에서 다른 프로그램을 실행하고 싶거나 명령어를 수행하고 싶을 때 사용하는 모듈.

이 모듈을 통해 다른 언어의 코드를 실행하고 결괏값을 받을 수 있다.

## 3.6 파일 시스템 접근하기

fs 모듈은 파일 시스템에 접근하는 모듈이다. 즉, 파일을 생성하거나 삭제하고, 읽거나 쓸 수 있으며 폴더도 만들거나 지울 수 있다.

### 3.6.1 동기 메서드와 비동기 메서드

노드는 대부분의 메서드를 비동기 방식으로 처리한다. 하지만 몇몇 메서드는 동기 방식으로 사용할 수 있는데, fs 모듈이 그런 메서드를 많이 갖고 있다.

### 3.6.2 버퍼와 스트림 이해하기

파일을 읽거나 쓰는 방식에는 크게 두 가지 방식, 즉 버퍼를 이용하는 방식과 스트림을 이용하는 방식이 있다.

영상을 시청할 때, 영상을 로딩하는 시간을 버퍼링한다라고 말하고, 영상을 실시간으로 송출할 때는 스트리밍한다고 말한다. 즉, 버퍼링은 영상을 재생할 수 있을 때까지 데이터를 모으는 동작이며, 스트리밍은 영상 데이터를 조금씩 전송하는 동작이다.

노드의 버퍼와 스트림도 비슷한 개념이다. 노드는 파일을 읽을 때 메모리에 파일 크기만큼 공간을 마련해두며 파일 데이터를 메모리에 저장한 뒤 사용자가 조작할 수 있도록 한다. 이 때 메모리에 저장된 데이터가 바로 버퍼이다.

### 3.6.3 기타 fs 메서드 알아보기

- fs.access(경로, 옵션, 콜백) :: 폴더나 파일에 접근할 수 있는지 확인한다.
- fs.mkdir(경로, 콜백) :: 폴더를 만드는 메서드. 이미 존재하는 폴더라면 에러가 발생하므로 access 메서드를 호출해서 확인하는 것이 좋다.
- fs.open(경로, 옵션, 콜백) :: 파일의 아이디(fd 변수)를 가져오는 메서드만약 파일이 없다면 파일을 생성한 뒤 그 아이디를 가져온다.
- fs.rename(기존 경로, 새 경로, 콜백) :: 파일의 이름을 바꾸는 메서드.꼭 같은 폴더를 지정할 필요는 없으므로 잘라내기 같은 기능을 할 수도 있다.
- fs.readdir(경로, 콜백) : 폴더 안의 내용물을 확인할 수 있다.
- fs.unlink(경로, 콜백) : 파일을 지울 수 있다.
- fs.rmdir(경로, 콜백) : 폴더를 지울 수 있다.

### 3.6.4 스레드풀 알아보기

비도익 메서드를 여러 번 실행해도 백그라운드에서 동시에 처리되는데, 이 이유가 스레드풀이 존재하기 때문이다. 스레드풀이 작업을 동시에 처리하게되면 어느 것이 먼저 처리될지 몰라서 실행할 때마다 시간과 순서가 달란진다. 스레드풀을 직접 컨트롤할 수는 없지만 개수는 조절 할 수 있다.

## 3.7 이벤트 이해

events 모듈을 사용하여 객체를 만들어서 사용한다. 이벤트 객체는 이벤트 관리를 위한 메서드를 갖고 있다.

## 3.8 예외 처리

노드에서는 예외 처리가 정말 중요하다. 예외란 보통 처리하지 못한 에러를 가리키는데, 이러한 예외들이 실행 중인 노드 프로세스를 멈추게 만들기 때문이다.

- 에러가 발생할 것 같은 부분을 try / catch 문으로 감싼다.
- 에러가 발생했을 때 에어를 throw 한다. (반드시 try / catch 문으로 throw 한 에러를 잡아야한다.)
- 프로미스의 에러는 catch하지 않아도 알아서 처리된다.
- process 객체에 uncaughtException 이벤트 리스너를 단다.

---

# 4. http 모듈 서버

## 4.1 요청과 응답 이해하기

서버는 클라이언트가 있기에 동작하며, 클라이언트에서 서버로 요청(request)을 보내고, 서버에서는 요청의 내용을 읽고 처리한 뒤 클라이언트에 응답(response)을 보낸다.

즉, 요청과 응답은 이벤트 방식이다.

## 4.2 REST와 라우팅 사용하기

REST는 REpresentational State Transfer의 줄임말로 서버의 자원을 정의하고 자원에 대한 주소를 지정하는 방법이다. 자원이라고 해서 꼭 파일이 아니어도 된다. 그저 서버가 행할 수 있는 것들을 통틀어서 의미한다고 보면된다.

- 주소는 의미를 명확히 전달하기 위해 명사로 구성된다.
- 단순히 명사만 있으면 무슨 동작을 하라는 것인지 알기어려워서 REST에서는 주소 외에도 HTTP 요청 메서드라는 것을 사용한다.GET : 서버 자원을 가져올때 사용. 요청 본문에 데이터를 넣지 않지만, 데이터를 서버로 보내야 한다면 쿼리스트링을 사용POST : 서버에 자원을 새로 등록할 때 사용. 요청 본문에 새로 등록할 데이터를 넣어 보냄PUT : 서버 자원을 요청에 들어 있는 자원으로 치환할 때 사용. 요청 본문에 치환할 데이터를 넣어 보냄PATCH : 서버 자원의 일부만 수정할 때 사용. 요청 본문에 일부 수정할 데이터를 넣어 보냄DELETE : 서버 자원을 삭제할 때 사용. 요청 본문에 데이터를 넣지 않음.OPTIONS : 요청 전, 통신 옵션을 설명하기 위해 사용.

> REST를 따르는 서버를 'RESTful 하다'고 표현한다.
> 

## 4.3 쿠키와 세션 이해하기

1. 쿠키
    - 유효 기간이 있으며, name = nari 와 같이 단순한 '키-값'의 쌍이다.
    - 문자열 형식으로 존재하며 쿠키간에는 세미콜론으로 구분된다.
    - 쿠키를 설정할 때, 여러 옵션(만료 시간(Expires), HttpOnly, Path 등)을 넣을 수 있지만 쿠키에 들어가면 안되는 글자 중에서 대표적으로 한글과 줄바꿈이 있다.
    - 서버로부터 쿠키가 오면 웹브라우저는 쿠키를 저장해두었다가 다음에 요청할 때마다 쿠키를 동봉해서 보낸다. 즉, 서버는 요청에 들어있는 쿠키를 읽어서 사용자가 누구인지 파악한다.

우리는 서버에서 브라우저로 쿠키를 보낼 때만 코드를 작성해서 처리하면 된다.

쿠키는 요청 헤더(Cookie)에 담겨 전송된다. 브라우저는 응답의 헤더(Set-Cookie)에 따라 쿠키를 저장한다.

1. 세션
    - 세션이라는 객체에 정보를 넣어서 세션아이디를 주고 받는 방식
    - 세션아이디는 꼭 쿠키를 사용해서 주고받지 않아도 된다.
    - 세션을 위해 사용하는 쿠키를 세션 쿠키라고 부른다.
    - 실제 배포용 서버에선느 세션을 레디스(Redis)나 멤캐시드(Memcached)같은 데이터베이스에 넣어둔다.

## 4.4 https와 http2

### 1. https

https 모듈은 웹 서버에 SSL암호화를 추가한다.

다시말해 GET이나 POST요청을 할 때, 오가는 데이터를 암호화해서 중간에 다른 사람이 요청을 가로채더라도 내용을 확인할 수 없게 한다.

https 모듈은 암호화를 적용하는 만큼 인증서가 필요하다.

인증서는 인증 기관에서 구입해야하며, Let's Encrypt 같은 기관에서 무료로 발급해주기도 한다.

### 2. http2

http2 모듈은 SSL 암호화와 더불어 최신 HTTP 프로토콜인 http/2 를 사용할 수 있다.

http/2는 기존 http/1.1보다 요청 및 응답 방식이 개선되어 훨씬 효율적으로 요청을 보낸다. 또한, http/2를 사용했을 때 웹의 속도도 많이 개선된다.

## 4.5 cluster

cluster 모듈은 기본적으로 싱글 프로세스로 동작하는 노드가 CPU코어를 모두 사용할 수 있게 해주는 모듈이다. 포트를 공유하는 노드 프로세스를 여러개 둘 수도 있으므로, 요청이 많이 들어왔을 때 병렬로 실행된 서버의 개수만큼 요청이 분산되게 할 수 있다.

단점은 세션을 메모리에 저장하는 경우 문제가 될 수 있지만, 이 문제는 레디스 등의 서버를 도입하여 해결할 수 있다.

예기치 못한 에러로인해 서버가 종료되는 현상을 방지하기 위해 클러스터링을 적용하는 것이 좋다. 직접 cluster 모듈로 클러스터링을 구현할 수 있지만, pm2 등의 모듈로 cluster 기능을 사용한다.

---

# 5. 패키지 매니저(npm)

## 5.1 npm 이란?

npm은 Node Package Manager의 약어로, 이름 그대로 노드 패키지 매니저이다.

대부분의 자바스크립트 프로그램은 패키지라는 이름으로 npm에 등록되어 있어서 특정 기능을 하는 패키지가 필요하다면 npm에서 찾아 설치하면 된다.

2020년 5월 기준, npm에는 125만개에 달하는 패키지가 등록되어 있으며 세계 최대 규모이다.

## 5.2 package.json 으로 패키지 관리하기

### package.json 이란?

설치한 패키지의 버전을 관리하는 파일. 같은 패키지라도 버전별로 기능이 다를 수 있어서 프로젝트를 설치할 때 패키지도 동일한 버전을 설치하지 않으면 문제가 생길 수 있기에 버전을 관리하는 파일이 필요하다.

> 노드 프로젝트를 시작하기 전에는 폴더 내부에 무조건 package.json부터 만들고 시작해야한다.
> 

package.json 을 만드는 명령어

```
$ npm init
```

### WARN

패키지를 설치하다보면 메시지 중에 WARN이 나오는데 이것은 단순한 경고이다. ERROR만 진짜 에러이므로 크게 걱정하지 않아도 된다.

### package-lock.json

package-lock.json의 내용을 보면 node_modules에 들어 있는 패키지들의 정확한 버전과 의존 관계가 담겨있다. npm으로 패키지를 설치, 수정, 삭제할 때마다 패키지들 간의 내부 의존 관계를 이 파일에 저장한다.

node_modules는 언제든지 npm install로 설치할 수 있으며, 깃 같은 버전 관리 프로그램과 같이 사용할 때도 **중요한 파일은 package.json** 이다.

### 전역(global) 설치

전역 설치 옵션은 패키지를 현재 폴더인 node_modules에 설치하는 것이 아니라 npm이 설치되어있는 폴더(/usr/local/lib/node_modules)에 설치하는 것이다.

이 폴더의 경로는 보통 시스템 환경 변수에 등록되어 있어서 전역으로 설치한 패키지는 콘솔의 명령어로 사용할 수 있다. 또한 전역 설치한 패키지는 package.json에 기록되지 않는다.

- * 전역으로 설치했다고 패키지를 모든 곳에서 사용한다는 의미는 아니다.

## 5.3 패키지 버전 이해하기

노드 패키지들의 버전은 항상 세 자리로 이루어져 있다. 그 이유는 SemVer 방식의 버전 넘버링을 따르기 때문이다.

### SemVer

SemVer는 Semantic Versioning(유의적 버전)의 약어이다. 버전을 구성하는 세 자리가 모두 의미를 가지고 있다는 뜻이다.

**1. 0. 7**

1. 가장 맨 앞. 첫 번째 자리는 **major 버전**0 = 초기 개발 중1부터 정식 버전을 의미한다.major 버전은 하위 호환이 안 될 정도로 패키지의 내용이 수정되었을 때 올린다.
2. 가운데. 두 번째 자리는 **minor 버전**minor 버전은 하위 호환이 되는 기능을 업데이트할 때 올린다.
3. 제일 마지막. 세 번째 자리는 **patch 버전**새로운 기능이 추가되기보다 기존 기능에 문제가 있어서 수정한 것을 내 놓았을 때 patch버전을 올린다.

**package.json 에는 SemVer식 외에도 버전앞에 ^,~,>,< 문자가 붙어있다.**

- ^ :: minor 버전까지만 설치하거나 업데이트한다.npm i express@^1.1.1 이라면, 1.1.1 이상부터 2.0.0 미만 버전까지 설치된다. 2.0.0은 설치되지 않는다. 1.x.x와 같이 표현할 수 있다.
- ~ :: patch 버전까지만 설치하거나 업데이트한다.npm i express@~1.1.1 이라면, 1.1.1 이상부터 1.2.0 미만 버전까지 설치된다. 1.1.x와 같은 표현도 가능하다. ~보다 ^이 많이 사용되는 이유는 minor 버전까지는 하위 호환이 보장되기 때문이다.
- . >, < >=, <=, = 는 알기 쉽게 초과, 미만, 이상, 이하, 동일을 의미한다.
- @latest : 안정된 최신 버전의 패키지를 설치한다. x 로도 표현가능하다.npm i express@latest 또는 npm i express@x
- @next : 가장 최근 배포판을 사용할 수 있다. @latest 와 다른 점은 안정되지 않은 알파나 베타 버전의 패키지를 설치할 수 있다는 것이다.

## 5.4 기타 npm 명령어

1. 업데이트할 수 있는 패키지가 있는지 확인 가능

```
$ npm outdated
```

1. 패키지 업데이트하기

```
$ npm update [패키지명]
```

1. 패키지 제거 2가지 방식.

```
$ npm uninstall [패키지명]
```

```
$ npm rm [패키지명]
```

1. npm 패키지 검색

```
$ npm search [패키지명]
```

1. 패키지 세부 정보 알고 싶을 때

```
$ npm info [패키지명]
```

- * package.json 의 내용과 의존 관계, 설치 가능한 버전 정보 등이 표시된다.
1. npm 로그인

```
npm adduser
npm whoami		//로그인한 사용자가 누구인지 알려줌
npm logout		//npm adduser로 로그인한 계정을 로그아웃
```

npm 공식 사이트에서 가입한 계정으로 로그인하면 된다.

나중에 패키지를 배포할 때 로그인이 필요하지만, 패키지를 배포하지 않을 계획이라면 가입할 필요가 없다.

1. package.json의 버전을 올릴때

```
$ npm version [버전]
```

1. 패키지를 설치 할 때 경고 메시지를 띄우게 하는 명령어

```
$ npm deprecate [패키지명] [버전] [메시지]
```

1. package.json 대신 package-lock.json에 기반하여 패키지를 설치

```
$ npm ci
```

- * 더 엄격하게 버전을 통제하여 패키지를 설치하고 싶을 때 사용

## 5.5 패키지 배포하기

1. 코딩에 앞서서 npm([https://www.npmjs.com](https://www.npmjs.com/)) 계정을 만들어야 한다.
2. package.json의 main부분의 파일명과 일치하도록 코드를 작성한 뒤
3. npm publish 명령어를 사용하여 배포한다.

---

# 9. 익스프레스 SNS 서비스

## 9.1 프로젝트 구조 갖추기

1. package.json 생성생성하는 방법은 2가지 이다. 직접 쓰거나, `npm init` 명령어로 작성하면 된다.
2. 시퀄라이즈 설치이 프로젝트에서는 MySQL 데이터베이스로 사용할 것이다. 아래 명령어를 호출하면 `node_modules` 폴더와 `package-lock.json`이 자동으로 생성된다.

```
$ npm i sequelize mysql2 sequelize-cli
$ npx sequelize init
```

1. 템플릿 파일을 넣을 views, 라우터 파일을 넣을 routes, 정적 파일을 넣을 public, passport패키지를 위한 passport 폴더들을 만든다.
2. 서버 코드다 담길 app.js, 설정값들을 담을 .env 파일 생성
- * 템플릿 엔진은 넌적스를 사용한다.

## 9.2 데이터베이스 세팅하기

MySQL과 시퀄라이즈로 데이터 베이스를 설정한다.

- 사용자 정보를 저장하는 모델provider 속성은 SNS 로그인한 경우, local : 로컬 로그인, kakao : 카카오 로그인 으로 저장해서 구분한다. 테이블 옵션으로 timestamps, paranoid 가 true 이므로 createdAt, updatedAt, deletedAt 컬럼도 생성된다.User : Post = 1 : NUser : User = N : M둘 다 User 모델이라서 구분하기 위해 as 옵션을 넣어야 함.
- 게시글 모델 : 게시글 내용, 이미지 경로 저장게시글 등록자 아이디를 담은 컬럼은 나중에 관계를 설정할 때, 시퀄라이즈가 알아서 생성함User : Post = 1 : NPost : Hashtag = N : M
- 해시태그 모델 : 태그 이름을 저장함해시태그 모델을 따로 두는 이유는 나중에 태그로 검색하기 위해서Hashtad : Post = N : M

## 9.3 Passport 모듈로 로드인 구현하기

passport 모듈은 이름처럼 우리의 서비스를 사용할 수 있게 해주는 여권 같은 역할을 한다.이것을 사용하면 기존의 SNS 서비스 계정으로 로그인 하는 것을 해결할 수 있다.

```
// Passport 관련 패키지 설치
$ npm i passport passport-local passport-kakao bcrypt
```

```
module.exports = () => {
    /**
     * 로그인시 실행
     * req.session(세션) 객체에 어떤 데이터를 저장할지 정하는 메서드
     * 사용자 정보 객체를 세션에 아이디로 저장
     */
    passport.serializeUser((user, done) => {
        /**
         * done( 첫 번째 인수, 두 번째 인수)
         * 첫 번째 인수 :: 에러 발생시 사용
         * 두 번째 인수 :: 저장하고 싶은 데이터
         */
        done(null, user.id);
    });

    /**
     * 세션에 저장한 아이디를 통해 사용자 정보 객체를 불러오는 것
     * 매요청시 실행. passport.sesseion 미들웨어가 이 메서드 호출함
     * serializeUser의 done 의 두번째 인수가 이 메서드의 매개변수가 됨
     * 여기서는 사용자 id
     */
    passport.deserializeUser((id, done) => {
        User.findOne({ where: { id } })
            .then(user => done(null, user))
            .catch(err => done(err));
    });

    local();
    kakao();
};
```

- * Passport는 로그인시의 동작을 전략(strategy)라는 용어로 표현한다.

### 9.3.1 로컬 로그인 구현하기

로컬 로그인이란 다른 SNS 서비스를 통해서 로그인하지 않고 자체적으로 회원가입 후 로그인하는 것을 의미한다.

Passport에서 이를 구현하려면 passport-local 모듈이 필요한데 이미 설치했으므로 로컬 로그인 전략만 세우면된다.

### 9.3.2 카카오 로그인 구현하기

카카오 로그인이란 로그인 인증 과정을 카카오에 맡기는 것을 뜻한다. SNS 로그인의 특징은 회원가입 절차가 따로 없다는 것이다. 대신에 SNS 로그인 전략은 로컬 로그인 전략보다 다소 복잡하다.

1. passport-kakao 모듈로부터 Strategy 생성자를 불러와 전략을 구현한다.
2. **GET /auth/kakao**로 접근하면 카카오 로그인 과정이 시작되고 로그인 후 성공 여부 결과를 **GET /auth/kakao/callback**으로 받는다.> 로컬 로그인과 다른점은 passport.authenticate 메서드에 콜백 함수를 제공하지 않는 것이다. 카카오 로그인은 로그인 성공시 내부적으로 req.login을 호출하기 때문이다.

## 9.4 multer 패키지로 이미지 업로드 구현하기

multer 패키지 설치

```
$ npm i multer
```

- 실제 서버 운영시현재 multer 패키지는 이미지를 서버 디스크에 저장한다. 간단하지만 서버에 문제가 생기면 이미지가 제공되지 않거나 손실될 수 있다. 클라우드 스토리지 같은 정적 파일 제공 서비스를 사용하여 이미지를 따로 저장하고 제공하는 것이 좋다. multer-s3 또는 multer-google-storage 같은 패키지를 이용해서 사용가능하다.
